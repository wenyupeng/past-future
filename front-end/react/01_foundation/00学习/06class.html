<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="x-ua-compatible" CONTENT="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!--react 底层核心库-->
</head>

<body>
<script>
    //构造函数生成实例对象
    function Person(x, y) {
        this.x = x
        this.y = y
    }

    Person.prototype.add = function () {
        console.log(this.x + this.y)
    }
    let p = new Person(1, 2)

    //ES6生成实例
    class Person_es6 {
        constructor(x, y) {
            this.x = x
            this.y = y
        }

        add() {
            console.log(this.x + this.y)
        }
    }

    let es6Obj = new Person_es6(2, 3)

    console.log(typeof Person_es6)
    console.log(Person_es6 == Person_es6.prototype.constructor)

    // class Persons{
    //     constructor() {
    //     }
    //     add(){}
    // }
    // 等价于
    // Persons.prototype={
    //     constructor(){},
    //     add(){}
    // }

    class B {
    }

    let b = new B()

    class Hello {
        constructor(x, y) {
            this.x = x
            // this.add = this.add.bind(this)//绑定方法add到实例上
        }

        add() {
            console.log(this.x)
        }
    }

    let test_hello = new Hello(2)
    test_hello.add()
    console.log('x:' + test_hello.hasOwnProperty('x'))
    console.log('y:' + test_hello.hasOwnProperty('y'))
    // 只要不是显式定义在实例上的属性，都归属于模板上(this.x = x, x 定义在实例上)

    // hasOwnProperty 指示对象自身属性中是否具有指定的属性
    console.log('实例 add():' + test_hello.hasOwnProperty('add')) // false ，// this.add = this.add.bind(this) 添加该方法后为true
    console.log('模板 add():' + test_hello.__proto__.hasOwnProperty('add'))
</script>

</body>
</html>