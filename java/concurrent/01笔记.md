# 并发编程的核心：
1. 分工：如何高效地拆解任务并分配给线程
2. 同步：线程之间如何协作：当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行。
   1. 管程：解决并发问题的关键
3. 互斥：同一时刻只允许一个线程访问共享资源

# 多线程导致结果不确定的主要问题（内存模型）
- 可见性问题
- 有序性问题
- 原子性问题

> ReadWriteLock、StampedLock：优化读多写少场景下锁的性能
> 无锁的数据结构：原子类
> 不共享变量或者变量只允许读：Thread Local和final关键字，Copy-on-write的模式

![img.png](img.png)

为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：
1. CPU 增加了缓存，以均衡与内存的速度差异；
2. 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；
3. 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用

可见性：一个线程对共享变量的修改，另一个线程能够立刻看到。

> 操作系统做任务切换，可以发生在任何一条CPU指令执行完。

原子性：一个或者多个操作在CPU执行的过程中不被终端的特性

有序性：程序按照代码的先后顺序执行。
```java
//编译器优化带来的bug
public class Singleton {
   static Singleton instance;
   static Singleton getInstance(){
      if (instance == null) {
         synchronized(Singleton.class) {
            if (instance == null)
               instance = new Singleton();
         }
      }
      return instance;
   }
}
// 常规理解：线程A，B同时调用**getInstance()**方法，在第一个判断过后两线程同时对**Singleton.class**加锁，而`JVM`保证只有一个线程加锁成功，另一个线程会处于等待状态, 
// 当第一个线程获得锁并创建对象成功后，第一个线程释放锁，第二个线程取得锁后进行判断，发现对象已创建，结束逻辑，释放锁。

// 可能出问题的点在`new`
// 常认为`new`操作为：
// 1. 分配一块内存 M
// 2. 在内存 M 上初始化 Singleton 对象
// 3. 然后 M 的地址赋值给 instance 变量

// 实际上`new`操作为：
// 1. 分配一块内存 M
// 2. 然后 M 的地址赋值给 instance 变量
// 3. 在内存 M 上初始化 Singleton 对象
```
> 导致的结果
> ![双重检查创建单例的一场执行路径.png](img/双重检查创建单例的一场执行路径.png)

--- 
> 缓存导致的可见性问题
> 线程切换带来的原子性问题
> 编译优化带来的有序性问题

---
解决可见性、有序性最直接的办法：禁用缓存和编译优化
Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。
三个关键字：`volatile`、`synchronized`、`final`
六项`Happens-Before`原则

---
- volatile：告诉编译器，对于变量的读写，不能使用CPU缓存，必须从内存中读取或写入
- Happens-Before：前面一个操作的结果对后续操作是可见的
---
- Happens-Before
1. 程序的顺序性规则：一个线程中，按照程序顺序，前面的操作Happens-Before于后续的任意操作，程序前面对某个变量的修改一定是对后续操作可见的。
> 代码按程序顺序
```java
class VolatileExample {
 int x = 0;
 volatile boolean v = false;
 public void writer() {
 x = 42; // x=42 happens before v =true
 v = true; 
 }
 public void reader() {
 if (v == true) {
 }
 }
}
```
2. volatile变量规则：对一个volatile变量的写操作，Happens-Before于后续对这个volatile变量的读操作。
```java
class VolatileExample {
 int x = 0;
 volatile boolean v = false;
 public void writer() {
 x = 42; 
 v = true; 
 }
 public void reader() {
 if (v == true) {
    System.out.println(x); //x=42 这里的读操作 在写操作之后
 }
 }
}
```
3. 传递性：如果A Happens-Before B，且B Happens-Before C，那么A Happens-Before C。
```java
class VolatileExample {
 int x = 0;
 volatile boolean v = false;
 public void writer() {
 x = 42; 
 v = true; 
 }
 public void reader() {
 if (v == true) {
    System.out.println(x); //x=42 先writer()，后reader()，x写->v写->v读，传递依赖
 }
 }
}
```
4. 管程中锁的规则：对一个锁的解锁 Happens-Before于后续对这个锁的加锁
```
synchronized (this) { // 加锁
 // x 是共享变量, 初始值 =10
 if (this.x < 12) {
 this.x = 12;
 }
} // 解锁
// 解锁的指令在加锁指令后
```
5. 线程start()规则：主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作
```
Thread B = new Thread(()->{
 // 主线程调用 B.start() 之前
 // 所有对共享变量的修改，此处皆可见
 // 此例中，var==77
});
// 此处对共享变量 var 修改
var = 77;
// 主线程启动子线程
B.start();
```
6. 线程join()规则：主线程A等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join()方法返回），主线程能够看到子线程的操作。
```
Thread B = new Thread(()->{
 // 此处对共享变量 var 修改
 var = 66;
});
// 例如此处对共享变量修改，
// 则这个修改结果对线程 B 可见
// 主线程启动子线程
B.start();
B.join()
// 子线程所有对共享变量的修改
// 在主线程调用 B.join() 之后皆可见
// 此例中，var==66
```
7. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
8. 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。