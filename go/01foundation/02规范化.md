# 规范化
## 非代码类
### 开源协议
内容应该不开源，原IAM框架为MIT协议，支持修改后闭源
### 文档规范
#### 系统README文档
````
# 项目名称
## 功能特性
<!-- 写一段简短的话描述项目 -->
## 软件架构
<!-- 描述该项目的核心功能点 -->
## 快速开始
### 依赖检查
<!-- 描述该项目的依赖，比如依赖的包、工具或者其他任何依赖项 -->
### 构建
<!-- 描述如何构建该项目 -->
### 运行
<!-- 描述如何运行该项目 -->
## 使用指南
<!-- 描述如何使用该项目 -->
## 使用指南如何贡献（暂不用）
<!-- 告诉其他开发者如果给该项目贡献源码 -->
## 许可证
````
#### 项目文档
建议使用云文档，代码与文档分离，可以飞书上维护，建议使用Markdown
目录划分与如下
- 系统说明
- 系统架构
- 系统资源
- 业务
  - 需求文档
    - 开发文档（按版本维护）
      - 接口设计
      - 接口交互（API）
    - 测试文档

#### API文档
对应开发文档中的接口交互，建议使用swagger或者apifox维护，有开环境后，内容统一维护在开发环境并同步到云文档
主要包含信息
- 接口变更历史
- 通用说明
- 数据结构说明
- 错误码描述
- API接口使用文档
  - 接口描述：描述接口实现了什么功能
  - 请求方法：HTTP get/post/put/delete ，接口的请求方法，格式为 HTTP方法 请求路径，如 POST /v1/users
  - 请求参数：接口的输入字段，必须阐明参数名称，参数类型，是否必须和参数描述（是否有输入限制，是否有默认值）
    - Header参数
    - Query参数
    - Body参数
    - Path参数
  - 输出参数：接口返回的字段，包含参数名称，参数类型和描述
  - 错误码说明：用于说明特殊的异常，如文件上传中断等
  - 请求示例：一个真实的API接口请求和返回示例
### 版本规范
建议使用语义化版本规范（SemVer，Semantic Versioning）
主版本号.次版本号.修订号（X.Y.Z），其中X、Y和Z为非负的整数，且禁止在数字前方补零
版本号可按以下规则递增：
1. 主版本号（MAJOR）：当做了不兼容的API修改。
2. 次版本号（MINOR）：当做了向下兼容的功能性新增及修改。偶数为稳定版本，奇数为开发版本
3. 修订号（PATCH）：当做了向下兼容的问题修正
### Commit规范
主要约束Commit Message内容
格式为：
Header type <需求ID> <故事ID> : 描述
Body
Footer（非必须）

其中Header type如下
- feat：新增功能
- fix：Bug修复
- perf：提高代码性能的变更
- style：代码格式的变更，比如用gofmt格式化代码、删除空格行等
- refactor：其他代码类的变更，这些变更不属于feat、fix、perf和style，例如简化代码、重命名变量、删除冗余代码等
- test：新增测试用例或是更新现有测试用例
- ci：持续集成和部署相关的改动，比如修改Jenkins、GitLab CI等CI配置文件或者更新systemd unit文件
- docs：文档类更新，包括修改用户文档或者开发文档等
- chore：其他类型、比如构建流程、依赖管理或者辅助工具的变动等

Body：描述与上一版本相比改动内容
Footer：描述不兼容的改动和关闭的Issue列表

### Merge 规范
通过gitlab的merge msg留痕
时间和日期：
参与人员：
审核人员：
是否审核通过：

开发分支建议关联故事ID
如果当前merge请求存在需要修改的内容，直接通过gitlab页面进行标注，提交人跟进修复情况，确认所有需修复内容都完成后，再通知审核人员进行二次评审。

master分支建议用作备份
新建Release分支用于发版，Release-版本号
新建qa分支用于测试，qa-版本号
开发人员自己维护自己的分支，dev-故事Id-开发人员

> 合并代码前先pull一下Release分支，提交合并的人员解决合并冲突，如果冲突为公用代码，需要联系公用代码维护人确认代码变更。

### 发布规范
待定，如果是流水线发布，可不用规范

## 代码类
### 代码风格

### 目录结构
要求：
1. 命名清晰：目录命名要清晰、简洁，不要太长，也不要太短，目录名要能清晰地表达出该目录实现的功能，并且目录名最好用单数。一方面是因为单数足以说明这个目录的功能，另一方面可以统一规范，避免单复混用的情况。
2. 功能明确：：一个目录所要实现的功能应该是明确的、并且在整个项目目录中具有很高的辨识度。也就是说，当需要新增一个功能时，我们能够非常清楚地知道把这个功能放在哪个目录下。
3. 全面性：目录结构应该尽可能全面地包含研发过程中需要的功能，例如文档、脚本、源码管理、API 实现、工具、第三方包、测试、编译产物等。
4. 可预测性：项目规模一定是从小到大的，所以一个好的目录结构应该能够在项目变大时，仍然保持之前的目录结构。
5. 可扩展性：每个目录下存放了同类的功能，在项目变大时，这些目录应该可以存放更多同类功能。

参照iam项目
Go应用
- 开发阶段
  - 前端
    - /web：前端代码存放目录，主要用来存放 Web 静态资源，服务端模板和单页应用（SPAs）
  - 后端
    - /cmd：一个项目有很多组件，可以把组件 main 函数所在的文件夹统一放在/cmd 目录下
    - /internal：存放私有应用和库代码
      - /internal/apiserver：该目录中存放真实的应用代码
      - /internal/pkg：存放项目内可共享，项目外不共享的包。建议是，一开始将所有的共享代码存放在 /internal/pkg 目录下，当该共享代码做好了对外开发的准备后，再转存到/pkg目录下
    - /pkg：该目录中存放可以被外部应用使用的代码库，其他项目可以直接通过 import 导入这里的代码
    - /vendor：项目依赖
    - /third_party：外部帮助工具，分支代码或其他第三方应用（例如 Swagger UI）
- 测试阶段
  - /test：用于存放其他外部测试应用和测试数据，能适应mock测试尽量用mock测试
- 部署阶段
- /configs：目录用来配置文件模板或默认配置。
- /deployments：用来存放 Iaas、PaaS 系统和容器编排部署配置和模板
- /init：存放初始化系统（systemd，upstart，sysv）和进程管理配置文件（runit，supervisord）

项目管理
- /Makefile：项目管理工具
- /scripts：目录主要用来存放脚本文件，实现构建、安装、分析等不同功能
- /build：存放安装包和持续集成相关的文件
- /tools：存放这个项目的支持工具
- /githooks：Git 钩子
- /assets：项目使用的其他资源 (图片、CSS、JavaScript 等）
- /website：放置项目网站相关的数据

文档
- /README.md：包含了项目的介绍、功能、快速安装和使用指引、详细的文档链接以及开发指引等
- /docs：存放设计文档、开发文档和用户文档等（除了 godoc 生成的文档）
- /CONTRIBUTING.md：用来说明如何
  贡献代码，如何开源协同等等
- /api：存放的是当前项目对外提供的各种不同类型的 API 接口定义文件
- /LICENSE：版权文件
- /CHANGELOG：当项目有更新时，为了方便了解当前版本的更新内容或者历史更新内容，需要将更新记录存放到 CHANGELOG 目录
- /examples：存放应用程序或者公共包的示例代码
### 接口规范
http: https://restfulapi.net/
rpc: 内部API不对外暴露
### 日志规范
待定
可参照IAM项目：格式：日期 时间 日志级别 包名 错误信息
### 错误码
待定
可参照IAM项目：docs/guide/zh-CN/api/error_code_generated.md
HTTP状态码+错误码