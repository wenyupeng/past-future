<!DOCTYPE html>
<html LANG="en">
<head>
    <meta charset="UTF-8">
    <title>1_类的基本知识</title>
</head>
<body>
<script type="text/javascript">
    // 创建一个Person类
    class Person{
        constructor(name,age) {
            // this 类的实力对象
            this.name =name
            this.age =age
        }

        // 一般方法
        speak(){
            // 类的原型对象上，供实例使用
            // 通过Person实力调用speak时，speak中的this指向Person实例对象
            console.log(`my name is ${this.name} . my age is ${this.age}`)
        }
    }
    class Dog{

    }
    //创建一个student类，继承于Person类
    class Student extends Person{
        constructor(name,age,grade) {
            super(name,age)
            this.grade = grade
        }
        // 一般方法
        speak(){
            // 类的原型对象上，供实例使用
            // 通过Person实力调用speak时，speak中的this指向Person实例对象
            console.log(`my name is ${this.name} . my age is ${this.age}, my grade is ${this.grade}`)
        }

        study(){
            console.log('study hard')
        }
    }
    //创建一个Person的实例对象
    const p1=new Person('tom',18) // Person {}
    const p2=new Person('jerry',19) // Person {}
    const dog= new Dog()
    console.log(p1)
    console.log(dog)
    p1.speak()
    p2.speak()
    p1.speak.call({a:1,b:2}) //更改函数里的this指向，这里this改为对象{a:1,b:2}

    const s1 =new Student('zhang',18,90)
    console.log(s1)
    s1.speak() // student 继承 person，自身无speak方法，speak方法在原型链上 __proto__
    /*
        总结
        1. 类中的构造器不是必须写的，要对实力进行一些初始化的操作，如添加指定属性时才写
        2. 如果A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须要调用的
        3. 类中所定义的方法，都是放在了类的原型对象上，供实例去使用
     */
</script>
</body>
</html>