# 并发编程的核心：
1. 分工：如何高效地拆解任务并分配给线程
2. 同步：线程之间如何协作：当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行。
   1. 管程：解决并发问题的关键
3. 互斥：同一时刻只允许一个线程访问共享资源

# 多线程导致结果不确定的主要问题（内存模型）
- 可见性问题
- 有序性问题
- 原子性问题

> ReadWriteLock、StampedLock：优化读多写少场景下锁的性能
> 无锁的数据结构：原子类
> 不共享变量或者变量只允许读：Thread Local和final关键字，Copy-on-write的模式

![img.png](img.png)

为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：
1. CPU 增加了缓存，以均衡与内存的速度差异；
2. 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；
3. 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用

可见性：一个线程对共享变量的修改，另一个线程能够立刻看到。

> 操作系统做任务切换，可以发生在任何一条CPU指令执行完。

原子性：一个或者多个操作在CPU执行的过程中不被终端的特性

有序性：程序按照代码的先后顺序执行。
```java
//编译器优化带来的bug
public class Singleton {
   static Singleton instance;
   static Singleton getInstance(){
      if (instance == null) {
         synchronized(Singleton.class) {
            if (instance == null)
               instance = new Singleton();
         }
      }
      return instance;
   }
}
// 常规理解：线程A，B同时调用**getInstance()**方法，在第一个判断过后两线程同时对**Singleton.class**加锁，而`JVM`保证只有一个线程加锁成功，另一个线程会处于等待状态, 
// 当第一个线程获得锁并创建对象成功后，第一个线程释放锁，第二个线程取得锁后进行判断，发现对象已创建，结束逻辑，释放锁。

// 可能出问题的点在`new`
// 常认为`new`操作为：
// 1. 分配一块内存 M
// 2. 在内存 M 上初始化 Singleton 对象
// 3. 然后 M 的地址赋值给 instance 变量

// 实际上`new`操作为：
// 1. 分配一块内存 M
// 2. 然后 M 的地址赋值给 instance 变量
// 3. 在内存 M 上初始化 Singleton 对象
```
> 导致的结果
> ![双重检查创建单例的一场执行路径.png](img/双重检查创建单例的一场执行路径.png)

--- 
> 缓存导致的可见性问题
> 线程切换带来的原子性问题
> 编译优化带来的有序性问题